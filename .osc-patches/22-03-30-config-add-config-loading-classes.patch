From 15258051323f6957afc47f567530b20736a57cbd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=A9r=C3=B4me=20Jutteau?= <jerome.jutteau@outscale.com>
Date: Wed, 30 Mar 2022 14:47:13 +0200
Subject: [PATCH] config: add config loading classes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Jérôme Jutteau <jerome.jutteau@outscale.com>
---
 osc/config_file.go      | 126 ++++++++++++++++++++++++++++
 osc/config_file_test.go | 179 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 305 insertions(+)
 create mode 100644 osc/config_file.go
 create mode 100644 osc/config_file_test.go

diff --git a/osc/config_file.go b/osc/config_file.go
new file mode 100644
index 00000000..4f93a951
--- /dev/null
+++ b/osc/config_file.go
@@ -0,0 +1,126 @@
+/*
+ * 3DS OUTSCALE API
+ *
+ * Welcome to the OUTSCALE API documentation.<br /><br />  The OUTSCALE API enables you to manage your resources in the OUTSCALE Cloud. This documentation describes the different actions available along with code examples.<br /><br />  Note that the OUTSCALE Cloud is compatible with Amazon Web Services (AWS) APIs, but some resources have different names in AWS than in the OUTSCALE API. You can find a list of the differences [here](https://docs.outscale.com/en/userguide/OUTSCALE-APIs-Reference.html).<br /><br />  You can also manage your resources using the [Cockpit](https://docs.outscale.com/en/userguide/About-Cockpit.html) web interface.
+ *
+ * API version: 1.18
+ * Contact: support@outscale.com
+ * Generated by: OpenAPI Generator (https://openapi-generator.tech)
+ */
+
+package osc
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"path"
+)
+
+type ConfigFile struct {
+	profiles map[string]Profile
+}
+
+type Profile struct {
+	AccessKey       string   `json:"access_key"`
+	SecretKey       string   `json:"secret_key"`
+	X509ClientCert  string   `json:"x509_client_cert"`
+	X509_client_key string   `json:"x509_client_key"`
+	Protocol        string   `json:"protocol"`
+	Method          string   `json:"method"`
+	Region          string   `json:"region"`
+	Endpoints       Endpoint `json:"endpoints"`
+}
+
+type Endpoint struct {
+	API string `json:"api"`
+	FCU string `json:"fcu"`
+	LBU string `json:"lbu"`
+	EIM string `json:"eim"`
+	ICU string `json:"icu"`
+	OOS string `json:"oos"`
+}
+
+func NewConfigFile() *ConfigFile {
+	return &ConfigFile{
+		profiles: make(map[string]Profile),
+	}
+}
+
+func defaultConfigPath() (string, error) {
+	home, err := os.UserHomeDir()
+	if err != nil {
+		return "", err
+	}
+	return path.Join(home, ".osc", "config.json"), nil
+}
+
+func LoadDefaultConfigFile() (*ConfigFile, error) {
+	configPath, err := defaultConfigPath()
+	if err != nil {
+		return nil, err
+	}
+	return LoadConfigFile(&configPath)
+}
+
+func LoadConfigFile(path *string) (*ConfigFile, error) {
+	if path == nil || len(*path) == 0 {
+		return nil, errors.New("no path provided")
+	}
+	config_json, err := ioutil.ReadFile(*path)
+	if err != nil {
+		return nil, err
+	}
+	configFile := NewConfigFile()
+	if err := json.Unmarshal(config_json, &configFile.profiles); err != nil {
+		return nil, err
+	}
+	return configFile, nil
+}
+
+func (config *ConfigFile) Context(profileName string) (*context.Context, error) {
+	profile, ok := config.profiles[profileName]
+	if !ok {
+		return nil, errors.New("profile not found for creating Context, did you load config file?")
+	}
+	context := context.WithValue(context.Background(), ContextAWSv4, AWSv4{
+		AccessKey: profile.AccessKey,
+		SecretKey: profile.SecretKey,
+	})
+	return &context, nil
+}
+
+func (config *ConfigFile) ConfigFromProfileEndpoint(profileName string) (*Configuration, error) {
+	profile, ok := config.profiles[profileName]
+	if !ok {
+		return nil, errors.New("profile not found for creating Config, did you load config file?")
+	}
+	if len(profile.Endpoints.API) == 0 {
+		return nil, errors.New("profile does not specify API's endpoint")
+	}
+	protocol := "https"
+	if len(profile.Protocol) > 0 {
+		protocol = profile.Protocol
+	}
+	url := fmt.Sprintf("%s://%s", protocol, profile.Endpoints.API)
+	oscConfig := NewConfiguration()
+	oscConfig.BasePath = url
+	oscConfig.Servers = []ServerConfiguration{}
+	return oscConfig, nil
+}
+
+func (config *ConfigFile) ConfigFromProfileRegion(profileName string) (*Configuration, error) {
+	profile, ok := config.profiles[profileName]
+	if !ok {
+		return nil, errors.New("profile not found for creating Config, did you load config file?")
+	}
+	if len(profile.Region) == 0 {
+		return nil, errors.New("profile does not specify region parameter")
+	}
+	oscConfig := NewConfiguration()
+	oscConfig.BasePath, _ = oscConfig.ServerUrl(0, map[string]string{"region": profile.Region})
+	return oscConfig, nil
+}
diff --git a/osc/config_file_test.go b/osc/config_file_test.go
new file mode 100644
index 00000000..f2a2ce14
--- /dev/null
+++ b/osc/config_file_test.go
@@ -0,0 +1,179 @@
+package osc
+
+import (
+	"fmt"
+	"os"
+	"testing"
+)
+
+func TestBasicConfigFileWithValidEndpoint1(t *testing.T) {
+	ak := os.Getenv("OSC_ACCESS_KEY")
+	sk := os.Getenv("OSC_SECRET_KEY")
+	region := os.Getenv("OSC_REGION")
+	content := fmt.Sprintf(`{
+	"SomeProfile": {
+		"access_key": "%s",
+		"secret_key": "%s",
+		"protocol": "https",
+		"method": "post",
+		"region": "bad-region-that-should-not-impact",
+		"endpoints": {
+			"api": "api.%s.outscale.com/api/v1"
+		}
+	}}`, ak, sk, region)
+	configPath := "/tmp/osc-sdk-go-TestBasicConfigFileWithValidEndpoint1"
+	if err := testDumpToFile(configPath, content); err != nil {
+		t.Fatalf("Error: %s", err.Error())
+	}
+	defer os.Remove(configPath)
+	testBasicConfigWithValidEndpoint(t, configPath)
+}
+
+func TestBasicConfigFileWithValidEndpoint2(t *testing.T) {
+	ak := os.Getenv("OSC_ACCESS_KEY")
+	sk := os.Getenv("OSC_SECRET_KEY")
+	region := os.Getenv("OSC_REGION")
+	content := fmt.Sprintf(`{
+		"SomeProfile": {
+			"access_key": "%s",
+			"secret_key": "%s",
+			"endpoints": {
+				"api": "api.%s.outscale.com/api/v1"
+			}
+		}}`, ak, sk, region)
+	configPath := "/tmp/osc-sdk-go-TestBasicConfigFileWithValidEndpoint2"
+	if err := testDumpToFile(configPath, content); err != nil {
+		t.Fatalf("Error: %s", err.Error())
+	}
+	defer os.Remove(configPath)
+	testBasicConfigWithValidEndpoint(t, configPath)
+}
+
+func testBasicConfigWithValidEndpoint(t *testing.T, configPath string) {
+	configFile, err := LoadConfigFile(&configPath)
+	if err != nil {
+		t.Fatalf("Cannot load configuration file: %s", err.Error())
+	}
+	_, err = configFile.ConfigFromProfileEndpoint("non-existant")
+	if err == nil {
+		t.Fatalf("profile 'non-existant' should not exist")
+	}
+	config, err := configFile.ConfigFromProfileEndpoint("SomeProfile")
+	if err != nil {
+		t.Fatalf("profile 'SomeProfile' should exist (ConfigFromProfileEndpoint()): %s", err.Error())
+	}
+	_, err = configFile.Context("non-existant")
+	if err == nil {
+		t.Errorf("profile 'non-existant' should not exist (Context())")
+	}
+	auth, err := configFile.Context("SomeProfile")
+	if err != nil {
+		t.Fatalf("profile 'SomeProfile' should exist (Context()): %s", err.Error())
+	}
+	client := NewAPIClient(config)
+	_, _, err = client.SubregionApi.ReadSubregions(*auth, nil)
+	if err != nil {
+		t.Fatalf("Error while reading subregions: %s", err.Error())
+	}
+}
+
+func TestBasicConfigFileWithValidRegion1(t *testing.T) {
+	ak := os.Getenv("OSC_ACCESS_KEY")
+	sk := os.Getenv("OSC_SECRET_KEY")
+	region := os.Getenv("OSC_REGION")
+	content := fmt.Sprintf(`{
+		"SomeProfile": {
+			"access_key": "%s",
+			"secret_key": "%s",
+			"protocol": "https",
+			"method": "post",
+			"region": "%s",
+			"endpoints": {
+				"api": "api.bad-region-which-should-not-impact.outscale.com/api/v1"
+			}
+		}}`, ak, sk, region)
+	configPath := "/tmp/osc-sdk-go-TestBasicConfigFileWithValidRegion1"
+	if err := testDumpToFile(configPath, content); err != nil {
+		t.Fatalf("Error: %s", err.Error())
+	}
+	defer os.Remove(configPath)
+	testBasicConfigWithValidRegion(t, configPath)
+}
+
+func TestBasicConfigFileWithValidRegion2(t *testing.T) {
+	ak := os.Getenv("OSC_ACCESS_KEY")
+	sk := os.Getenv("OSC_SECRET_KEY")
+	region := os.Getenv("OSC_REGION")
+	content := fmt.Sprintf(`{
+		"SomeProfile": {
+			"access_key": "%s",
+			"secret_key": "%s",
+			"region": "%s"
+		}}`, ak, sk, region)
+	configPath := "/tmp/osc-sdk-go-TestBasicConfigFileWithValidRegion2"
+	if err := testDumpToFile(configPath, content); err != nil {
+		t.Fatalf("Error: %s", err.Error())
+	}
+	defer os.Remove(configPath)
+	testBasicConfigWithValidRegion(t, configPath)
+}
+
+func testDumpToFile(path string, content string) error {
+	jsonFile, err := os.Create(path)
+	if err != nil {
+		return err
+	}
+	defer jsonFile.Close()
+	if _, err := jsonFile.WriteString(content); err != nil {
+		return err
+	}
+	return nil
+}
+
+func testBasicConfigWithValidRegion(t *testing.T, configPath string) {
+	configFile, err := LoadConfigFile(&configPath)
+	if err != nil {
+		t.Fatalf("Cannot load configuration file: %s", err.Error())
+	}
+	_, err = configFile.ConfigFromProfileEndpoint("non-existant")
+	if err == nil {
+		t.Fatal("profile 'non-existant' should not exist")
+	}
+	config, err := configFile.ConfigFromProfileRegion("SomeProfile")
+	if err != nil {
+		t.Errorf("profile 'SomeProfile' should exist (ConfigFromProfileEndpoint()): %s", err.Error())
+	}
+	_, err = configFile.Context("non-existant")
+	if err == nil {
+		t.Fatal("profile 'non-existant' should not exist (Context())")
+	}
+	auth, err := configFile.Context("SomeProfile")
+	if err != nil {
+		t.Fatalf("profile 'SomeProfile' should exist (Context()): %s", err.Error())
+	}
+	client := NewAPIClient(config)
+	_, _, err = client.SubregionApi.ReadSubregions(*auth, nil)
+	if err != nil {
+		t.Fatalf("Error while reading subregions: %s", err.Error())
+	}
+}
+
+func TestBadConfigFile1(t *testing.T) {
+	content := `{
+		"SomeProfile": {
+			Garbage
+		}}`
+	configPath := "/tmp/osc-sdk-go-TestBadConfigFile2"
+	if err := testDumpToFile(configPath, content); err != nil {
+		t.Fatalf("Error: %s", err.Error())
+	}
+	defer os.Remove(configPath)
+	testBadConfigFile(t, configPath)
+}
+
+func testBadConfigFile(t *testing.T, configPath string) {
+	_, err := LoadConfigFile(&configPath)
+	if err == nil {
+		t.Fatal("Config file should not have loaded")
+	}
+}
-- 
2.35.1

